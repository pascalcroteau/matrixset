% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fn.R
\name{loop}
\alias{loop}
\alias{apply_row}
\alias{apply_row.matrixset}
\alias{apply_row.row_grouped_ms}
\alias{apply_row.col_grouped_ms}
\alias{apply_row.dual_grouped_ms}
\alias{apply_column}
\alias{apply_column.matrixset}
\alias{apply_column.col_grouped_ms}
\alias{apply_column.row_grouped_ms}
\alias{apply_column.dual_grouped_ms}
\alias{apply_row_dfl}
\alias{apply_row_dfl.matrixset}
\alias{apply_row_dfl.row_grouped_ms}
\alias{apply_row_dfl.col_grouped_ms}
\alias{apply_row_dfl.dual_grouped_ms}
\alias{apply_column_dfl}
\alias{apply_column_dfl.matrixset}
\alias{apply_column_dfl.col_grouped_ms}
\alias{apply_column_dfl.row_grouped_ms}
\alias{apply_column_dfl.dual_grouped_ms}
\alias{apply_row_dfw}
\alias{apply_row_dfw.matrixset}
\alias{apply_row_dfw.row_grouped_ms}
\alias{apply_row_dfw.col_grouped_ms}
\alias{apply_row_dfw.dual_grouped_ms}
\alias{apply_column_dfw}
\alias{apply_column_dfw.matrixset}
\alias{apply_column_dfw.col_grouped_ms}
\alias{apply_column_dfw.row_grouped_ms}
\alias{apply_column_dfw.dual_grouped_ms}
\alias{apply_mat}
\alias{apply_mat.matrixset}
\alias{apply_mat.row_grouped_ms}
\alias{apply_mat.col_grouped_ms}
\alias{apply_mat.dual_grouped_ms}
\alias{apply_mat_dfl}
\alias{apply_mat_dfl.matrixset}
\alias{apply_mat_dfl.row_grouped_ms}
\alias{apply_mat_dfl.col_grouped_ms}
\alias{apply_mat_dfl.dual_grouped_ms}
\alias{apply_mat_dfw}
\alias{apply_mat_dfw.matrixset}
\alias{apply_mat_dfw.row_grouped_ms}
\alias{apply_mat_dfw.col_grouped_ms}
\alias{apply_mat_dfw.dual_grouped_ms}
\title{Apply functions to each matrix of a matrixset}
\usage{
apply_row(.ms, ..., .matrix = NULL)

\method{apply_row}{matrixset}(.ms, ..., .matrix = NULL)

\method{apply_row}{row_grouped_ms}(.ms, ..., .matrix = NULL)

\method{apply_row}{col_grouped_ms}(.ms, ..., .matrix = NULL)

\method{apply_row}{dual_grouped_ms}(.ms, ..., .matrix = NULL)

apply_column(.ms, ..., .matrix = NULL)

\method{apply_column}{matrixset}(.ms, ..., .matrix = NULL)

\method{apply_column}{col_grouped_ms}(.ms, ..., .matrix = NULL)

\method{apply_column}{row_grouped_ms}(.ms, ..., .matrix = NULL)

\method{apply_column}{dual_grouped_ms}(.ms, ..., .matrix = NULL)

apply_row_dfl(.ms, ..., .matrix = NULL)

\method{apply_row_dfl}{matrixset}(.ms, ..., .matrix = NULL)

\method{apply_row_dfl}{row_grouped_ms}(.ms, ..., .matrix = NULL)

\method{apply_row_dfl}{col_grouped_ms}(.ms, ..., .matrix = NULL)

\method{apply_row_dfl}{dual_grouped_ms}(.ms, ..., .matrix = NULL)

apply_column_dfl(.ms, ..., .matrix = NULL)

\method{apply_column_dfl}{matrixset}(.ms, ..., .matrix = NULL)

\method{apply_column_dfl}{col_grouped_ms}(.ms, ..., .matrix = NULL)

\method{apply_column_dfl}{row_grouped_ms}(.ms, ..., .matrix = NULL)

\method{apply_column_dfl}{dual_grouped_ms}(.ms, ..., .matrix = NULL)

apply_row_dfw(.ms, ..., .matrix = NULL)

\method{apply_row_dfw}{matrixset}(.ms, ..., .matrix = NULL)

\method{apply_row_dfw}{row_grouped_ms}(.ms, ..., .matrix = NULL)

\method{apply_row_dfw}{col_grouped_ms}(.ms, ..., .matrix = NULL)

\method{apply_row_dfw}{dual_grouped_ms}(.ms, ..., .matrix = NULL)

apply_column_dfw(.ms, ..., .matrix = NULL)

\method{apply_column_dfw}{matrixset}(.ms, ..., .matrix = NULL)

\method{apply_column_dfw}{col_grouped_ms}(.ms, ..., .matrix = NULL)

\method{apply_column_dfw}{row_grouped_ms}(.ms, ..., .matrix = NULL)

\method{apply_column_dfw}{dual_grouped_ms}(.ms, ..., .matrix = NULL)

apply_mat(.ms, ..., .matrix = NULL)

\method{apply_mat}{matrixset}(.ms, ..., .matrix = NULL)

\method{apply_mat}{row_grouped_ms}(.ms, ..., .matrix = NULL)

\method{apply_mat}{col_grouped_ms}(.ms, ..., .matrix = NULL)

\method{apply_mat}{dual_grouped_ms}(.ms, ..., .matrix = NULL)

apply_mat_dfl(.ms, ..., .matrix = NULL)

\method{apply_mat_dfl}{matrixset}(.ms, ..., .matrix = NULL)

\method{apply_mat_dfl}{row_grouped_ms}(.ms, ..., .matrix = NULL)

\method{apply_mat_dfl}{col_grouped_ms}(.ms, ..., .matrix = NULL)

\method{apply_mat_dfl}{dual_grouped_ms}(.ms, ..., .matrix = NULL)

apply_mat_dfw(.ms, ..., .matrix = NULL)

\method{apply_mat_dfw}{matrixset}(.ms, ..., .matrix = NULL)

\method{apply_mat_dfw}{row_grouped_ms}(.ms, ..., .matrix = NULL)

\method{apply_mat_dfw}{col_grouped_ms}(.ms, ..., .matrix = NULL)

\method{apply_mat_dfw}{dual_grouped_ms}(.ms, ..., .matrix = NULL)
}
\arguments{
\item{.ms}{\code{matrixset} object}

\item{...}{expressions, separated by commas. They can be specified in one of
the following way:
\itemize{
\item a function name, e.g., \code{mean}.
\item a function call, where you can use \code{.m} to represent the current matrix
(for \code{apply_mat}), \code{.i} to represent the current row (for \code{apply_row})
and \code{.j} for the current column (\code{apply_column}). Bare names of object
traits can be used as well. For instance, \code{lm(.i ~ program)}.
\item a formula expression. The pronouns \code{.m}, \code{.i} and \code{.j} can be used as
well. See examples to see the usefulness of this.
}

The expressions can be named; these names will be used to provide names to
the results.}

\item{.matrix}{matrix indices of which matrix to apply functions to. The
default, \code{NULL}, means all the matrices are used.

If not \code{NULL}, index is numeric or character vectors.

Numeric values are coerced to integer as by \code{\link[=as.integer]{as.integer()}} (and hence
truncated towards zero).

Character vectors will be matched to the matrix names of the object.

Can also be logical vectors, indicating elements/slices to replace. Such
vectors are \emph{NOT} recycled, which is an important difference with usual
matrix replacement. It means that the \code{logical} vector must match the
number of matrices in length.

Can also be negative integers, indicating elements/slices to leave out of
the replacement.}
}
\value{
A list for every matrix in the matrixset object. Each list is itself a list.
For \code{apply_mat}, it is a list of the function values. Otherwise, it is a
list with one element for each row/column. And finally, for
\code{apply_row}/\code{apply_column}, each of these sub-list is a list, the results of
each function.

If each function returns a \code{vector} of the same dimension, you can use either
the \verb{_dfl} or the \verb{_dfw} version. What they do is to return a list of
\code{tibble}s. The \code{dfl} version will stack the function results in a long format
while the \code{dfw} version will put them side-by-side, in a wide format.

If the functions returned vectors of more than one element, there will be a
column to store the values and one for the function ID (dfl), or one column
per combination of function/result (dfw)

See the grouping section to learn about the result format in the grouping
context.
}
\description{
The \code{apply_mat} function applies functions to each matrix of a \code{matrixset}.
The \code{apply_row}/\code{apply_column} functions do the same but separately for the
row/column. The functions can be applied to all matrices or only a subset.

The \code{dfl}/\code{dfw} versions differ in their output format.
}
\section{Pronouns}{

The \code{rlang} pronouns \code{.data} and \code{.env} are available. Two scenarios for
which they can be useful are:
\itemize{
\item The annotation names are stored in a character variable. You can make use
of the variable by using \code{.data[[var]]}. See the example for an
illustration of this.
\item You want to make use of a global variable that has the same name as an
annotation. You can use \code{.env[[var]]} or \code{.env$var} to make sure to use
the proper variable.
}

The matrixset package defines its own pronouns: \code{.m}, \code{.i} and \code{.j}, which
are discussed in the function specification argument (\code{...}).

It is not necessary to import any of the pronouns (or load \code{rlang} in the
case of \code{.data} and \code{.env}) in a interactive session.

It is useful however when writing a package to avoid the \verb{R CMD check} notes.
As needed, you can import \code{.data} and \code{.env} (from \code{rlang}) or any of \code{.i},
\code{.j} or \code{.m} from \code{matrixset}.
}

\section{Grouped matrixsets}{

If groups have been defined, functions will be evaluated within them. When
both row and column grouping has been registered, functions are evaluated at
each cross-combination of row/column groups.

The output format is different when the \code{.ms} matrixset object is grouped.
A list for every matrix is still returned, but each of these lists now holds
a tibble.

Each tibble has a column called \code{.vals}, where the function results are
stored. This column is a list, one element per group. The group labels are
given by the other columns of the tibble. For a given group, things are like
the ungrouped version: further sub-lists for rows/columns - if applicable -
and function values.

The dfl/dfw versions are more similar in their output format to their
ungrouped version. The format is almost identical, except that additional
columns are reported to identify the group labels.

See the examples.
}

\examples{
# The firs example takes the whole matrix average, while the second takes
# every row average
(mn_mat <- apply_mat(student_results, mean))
(mn_row <- apply_row(student_results, mean))

# More than one function can be provided. It's a good idea in this case to
# name them
(mn_col <- apply_column(student_results, avr=mean, med=median))

# the dfl/dfw versions returns nice tibbles - if the functions return values
# of the same length.
(mn_l <- apply_column_dfl(student_results, avr=mean, med=median))
(mn_w <- apply_column_dfw(student_results, avr=mean, med=median))

# There is no difference between the two versions for length-1 vector results.
# hese will differ, however
(rg_l <- apply_column_dfl(student_results, rg=range))
(rg_w <- apply_column_dfw(student_results, rg=range))

# More complex examples can be used, by using pronouns and data annotation
(vals <- apply_column(student_results, avr=mean, avr_trim=mean(.j, trim=.05),
                                      reg=lm(.j ~ teacher)))

# You can wrap complex function results, such as for lm, into a list, to use
# the dfl/dfr version
(vals_tidy <- apply_column_dfw(student_results, avr=mean, avr_trim=mean(.j, trim=.05),
                                               reg=list(lm(.j ~ teacher))))

# You can provide complex expressions by using formulas
(r <- apply_column(student_results,
                                  res= ~ {
                                    log_score <- log(.j)
                                    p <- predict(lm(log_score ~ teacher + class))
                                    .j - exp(p)
                                  }))

# the .data pronoun can be useful to use names stored in variables
fn <- function(nm) {
  if (!is.character(nm) && length(nm) != 1) stop("this example won't work")
  apply_column(student_results, lm(.j ~ .data[[nm]]))
}
fn("teacher")

# You can use variables that are outside the scope of the matrixset object.
# You don't need to do anything special if that variable is not named as an
# annotation
pass_grade <- 0.5
(passed <- apply_row_dfw(student_results, pass = ~ .i >= pass_grade))

# use .env if shares an annotation name
previous_year_score <- 0.5
(passed <- apply_row_dfw(student_results, pass = ~ .i >= .env$previous_year_score))

# Grouping structure makes looping easy. Look at the output format
cl_prof_gr <- row_group_by(student_results, class, teacher)
(gr_summ <- apply_column(cl_prof_gr, avr=mean, med=median))
(gr_summ_tidy <- apply_column_dfw(cl_prof_gr, avr=mean, med=median))
# to showcase how we can play with format
(gr_summ_tidy_long <- apply_column_dfl(cl_prof_gr, summ = ~ c(avr=mean(.j), med=median(.j))))

# It is even possible to combine groupings
cl_prof_program_gr <- column_group_by(cl_prof_gr, program)
(mat_summ <- apply_mat(cl_prof_program_gr, avr = mean, med = median, rg = range))
# it doesn' make much sense, but this is to showcase format
(summ_gr <- apply_mat(cl_prof_program_gr, avr = mean, med = median, rg = range))
(summ_gr_long <- apply_column_dfl(cl_prof_program_gr,
                                 ct = ~ c(avr = mean(.j), med = median(.j)),
                                 rg = range))
(summ_gr_wide <- apply_column_dfw(cl_prof_program_gr,
                                 ct = c(avr = mean(.j), med = median(.j)),
                                 rg = range))

}
