% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fn.R
\name{loop}
\alias{loop}
\alias{row_loop}
\alias{row_loop.matrixset}
\alias{row_loop.row_grouped_ms}
\alias{row_loop.col_grouped_ms}
\alias{column_loop}
\alias{column_loop.matrixset}
\alias{column_loop.col_grouped_ms}
\alias{column_loop.row_grouped_ms}
\alias{row_loop_dfl}
\alias{row_loop_dfl.matrixset}
\alias{row_loop_dfl.row_grouped_ms}
\alias{row_loop_dfl.col_grouped_ms}
\alias{column_loop_dfl}
\alias{column_loop_dfl.matrixset}
\alias{column_loop_dfl.col_grouped_ms}
\alias{column_loop_dfl.row_grouped_ms}
\alias{row_loop_dfw}
\alias{row_loop_dfw.matrixset}
\alias{row_loop_dfw.row_grouped_ms}
\alias{row_loop_dfw.col_grouped_ms}
\alias{column_loop_dfw}
\alias{column_loop_dfw.matrixset}
\alias{column_loop_dfw.col_grouped_ms}
\alias{column_loop_dfw.row_grouped_ms}
\title{Apply functions to each matrix row/column of a matrixset}
\usage{
row_loop(.ms, ..., .matrix = NULL)

\method{row_loop}{matrixset}(.ms, ..., .matrix = NULL)

\method{row_loop}{row_grouped_ms}(.ms, ..., .matrix = NULL)

\method{row_loop}{col_grouped_ms}(.ms, ..., .matrix = NULL)

column_loop(.ms, ..., .matrix = NULL)

\method{column_loop}{matrixset}(.ms, ..., .matrix = NULL)

\method{column_loop}{col_grouped_ms}(.ms, ..., .matrix = NULL)

\method{column_loop}{row_grouped_ms}(.ms, ..., .matrix = NULL)

row_loop_dfl(.ms, ..., .matrix = NULL)

\method{row_loop_dfl}{matrixset}(.ms, ..., .matrix = NULL)

\method{row_loop_dfl}{row_grouped_ms}(.ms, ..., .matrix = NULL)

\method{row_loop_dfl}{col_grouped_ms}(.ms, ..., .matrix = NULL)

column_loop_dfl(.ms, ..., .matrix = NULL)

\method{column_loop_dfl}{matrixset}(.ms, ..., .matrix = NULL)

\method{column_loop_dfl}{col_grouped_ms}(.ms, ..., .matrix = NULL)

\method{column_loop_dfl}{row_grouped_ms}(.ms, ..., .matrix = NULL)

row_loop_dfw(.ms, ..., .matrix = NULL)

\method{row_loop_dfw}{matrixset}(.ms, ..., .matrix = NULL)

\method{row_loop_dfw}{row_grouped_ms}(.ms, ..., .matrix = NULL)

\method{row_loop_dfw}{col_grouped_ms}(.ms, ..., .matrix = NULL)

column_loop_dfw(.ms, ..., .matrix = NULL)

\method{column_loop_dfw}{matrixset}(.ms, ..., .matrix = NULL)

\method{column_loop_dfw}{col_grouped_ms}(.ms, ..., .matrix = NULL)

\method{column_loop_dfw}{row_grouped_ms}(.ms, ..., .matrix = NULL)
}
\arguments{
\item{.ms}{\code{matrixset} object}

\item{...}{functions, separated by commas. They can be specified in one of
the following way:
\itemize{
\item a function name, e.g., \code{mean}.
\item a function call, where you can use \code{.i} to represent the current row
(for \code{row_loop}) and \code{.j} for the current column (\code{column_loop}). Bare
names of object traits can be used as well. For instance,
\code{lm(.i ~ program)}.
\item a formula expression. See examples to see the usefulness of this.
}}

\item{.matrix}{matrix indices of which matrix to apply functions to. The
default, \code{NULL}, means all the matrices are used.

If not \code{NULL}, index is numeric or character vectors.

Numeric values are coerced to integer as by \code{\link[=as.integer]{as.integer()}} (and hence
truncated towards zero).

Character vectors will be matched to the matrix names of the object.

Can also be logical vectors, indicating elements/slices to replace. Such
vectors are \emph{NOT} recycled, which is an important difference with usual
matrix replacement. It means that the \code{logical} vector must match the
number of matrices in length.

Can also be negative integers, indicating elements/slices to leave out of
the replacement.}
}
\value{
A list for every matrix in the matrixset object. Each list is itself a list,
one element for each row/column. And finally, each of these sub-list is a
list, the results of each function.

If each function returns a vector of the same dimension, you can use either
the \verb{_dfl} or the \verb{_dfw} version. What they do is to return a list of
\code{tibble}s. The \code{dfl} version will stack the function results, in a long
format while the \code{dfw} version will put them side-by-side, in a wide format.

See the grouping section to learn about the result format in the grouping
context.
}
\description{
The \code{row_loop}/\code{column_loop} functions apply functions to each matrix
row/column of a \code{matrixset}. The functions can be applied to all matrices or
only a subset.

The \code{dfl}/\code{dfw} versions differ in their output format.
}
\section{vector \code{value}}{

Contrarily to \code{matrix} replacement, when submitting an atomic \code{vector}
\code{value}, dimensions must match exactly.
}

\examples{
# an hypothetical example of students that failed 3 courses and their results
# after remedial class
set.seed(1121)
failure <- matrix(runif(20*3,0,.5), 20, 3)
remedial <- matrix(c(c(runif(10, 0.55, 0.75), runif(10, 0.65, 0.8)),
                     runif(20, 0.65, 0.90),
                     c(runif(10, 0.6, 0.8), runif(10, 0.65, 0.95))), 20, 3)
rownames(failure) <- rownames(remedial) <- paste("student", 1:20)
colnames(failure) <- colnames(remedial) <- c("Mathematics", "English", "Science")
student_info <- data.frame(student = paste("student", 1:20),
                           class = gl(4,5,labels = paste0("class", LETTERS[1:4])),
                           teacher = gl(2,10,labels = paste0("Professor", 1:2)))
student_results <- matrixset(failure = failure, remedial = remedial,
                             row_info = student_info, row_key = "student")

# you can replace a line for all matrices at once. In the example, the "wrong"
# tag refers to the fact that the 'failure' results do not make sense after
# replacement
student_results_wrong <- student_results
student_results_wrong["student 2",,] <- c(0.81, 0.88, 0.71) # obviously, integer index works too
# note how all matrices had the same replacement
student_results_wrong

# this already makes more sense in the context of the example
student_results[2,,] <- list(c(0,0.45,0.1), c(0.81, 0.88, 0.71))
student_results

# or even these two equivalent commands
student_results["student 2",,"remedial"] <- c(0.77, 0.83, 0.75)
student_results[2,,2] <- matrix(c(0.77, 0.83, 0.75), 1, 3)

}
